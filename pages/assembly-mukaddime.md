# x86 Assembly Yazılarının Mukaddimesi 
Tarih:​​13 Şubat 2021​ | Yazar:​​ffc12

x86 mimarisine ait bir Assembly yazı dizgesi hazırlamaya karar verdim.Her yazıdax86 mimarisinin assembly diline dair birçok farklı konuyu ele alacağım (çok da detaylı değil)yazılara başlamadan evvel bir mukaddime yazısı yazmayı uygun gördüm. Bu mukaddimeyazısında hızlı bir giriş yaparak genel bir bakış kazandırmaya çalışacağım.Hem de bu yazıdizgesinden istifade etmek isteyenlerin ön araştırma yapmalarına yardımcı olacak kapsamdada bahislere yer vereceğim.Ayrıca şimdiden belirtmeliyim ki bu yazıda bazı literatüre geçmişkelimeleri, kavramları doğrudan sözcüksel bir çeviri yaparak/yapmaya çalışarakkullanmayacağım. Bu tür,bazı kavramların doğrudan çevirisinin yapılması neredeyseimkansız; bilhassa manasız. Mesela “expression” ile “statement” için doğrudan bir çeviriyapmaya kalkarsanız büyük bir hüsrana uğrarsınız. Bu ve bunun gibi birçok bilgisayarbilimleri kavramları mevcut. Dolayısıyla kavramları bağlamına uygun şekilde birer cümle ileifade etmeye çalışacağım. Genel olarak sözcüğü olduğu gibi, literatürde geçtiği haliylekullanmak üzere rahat bırakacağım.Ayrıca bir ciddiyetle takip edip neticede öğretici bir tarafı olan bu yazı dizgesinden azamiölçüde istifade etmek isteyenlere bazı tavsiyelerim olabilir:

●Aynı anda kapsamlı araştırmalar yaparak, paralel olarak takip edin.
●Kavramları etimolojik olarak da inceleyin.
●Not alın.
●Okuduğunuz iki yazı arasında uzun bir müddet varsa aldığınızı varsaydığımnotlarınızı tekrar edin.

Başlamadan önce son bir uyarı: Bu yazıda “x86 Assembly” dan “Assembly” diyebahsedilecektir​.​Okuma önerilerinin ve bazı referansların kimisi metin içerisindekimisinde yazının en alt kısmında paylaşılmıştır.

#### Her Problemi Çözen Tek Bir Problem Vardır

Hemen her programlama dilini öğrenmeye başladığımızda yazdığımız ilk program bir “Hello,world!” programı olur.Bu teamülü devam ettirerek biz de banal bir “Hello, world!” programınıAssembly ile yazalım hemen.
 
```
global​ main
extern​ printf
section​ .data​
	fmt:  db  '%s' , 0x0a, 0​
	msg:  db  'Hello world!'​,​0
section​ .text
main:​
	mov esi​, msg​
	mov edi​, fmt​
	mov eax​, ​0​
	call printf​
	ret 
```


Bu sıradan "Hello, world!” programının daha önce hiç “Assembly nedir?” diye merak edipbakmamış olan birisi için anlamsız yahud korkutucu gelebileceğini tahminedebiliyorum.Ancak bu basit program tek başına size Assembly’yi öğretebilecek kadar farklıözelliği ve sentaks kurallarını ihtiva ediyor. Tabi bu mübalağa bir kod parçası gördüğünüzdeen azından “Burada neler yapılmış?” sorusuna cevap verebilecek bir noktaya kadaranlamlı.Gerçek dünyada bir program üzerinde reverse engineering (tersine mühendislik)yaparken veya compiler’ın ürettiği bir optimize (-02 veya -03 flagleri gibi ) Assembly kodunuincelerken, kafanız karışmadan ve belki anlamak için uzun süreler harcamadan bu pekmümkün olmayacaktır. Ancak bu korkulacak veya endişe edilecek bir şey değildir.Assemblyöğrenerek bir nevi hiç yoktan aslında tarihsel olarak geçmişe doğru bir yolculuk yaptığınızıdüşünebilirsiniz. Nerelerde ve nasıl işinize yaracağı konusuyla ilgili burada bir bahisolmayacak. O konuda da sanırım araştırma yaparak pekçok sonuca ulaşmanız mümkün.Ama değerli bir bakış açısı kazandıracağı kesin olarak, yaptığınız veya yapmakta olduğunuzrutin programlama işlerinize daha derinlikli bir anlam katacaktır. Ayrıca biraz belki özgüventazelemenize de yardımı dokunabilir.“

#### Hello, world!” ten Öncesine Geri Dönelim (Flashback)

Yazı serisinin ikinci bölümünde ele alacağımız “Hello, world!” ün öncesine geri dönüyoruz.Bugeriye dönüş “Bir bilgisayar nasıl çalışır?” sorusuna kadar gidecektir. İşte bu noktadakarşımıza birkaç tane de son derece önemli ara soru çıkmaktadır.Bize güzel cevaplarverecek bu özdeş sorular bir silsileyle şu şekilde gösterilebilir:

1. "Bir bilgisayar nasıl çalışır?” ​**ın bizi götürdüğü** ​“Bir işlemci/mikroişlemci nasıl çalışır? ”sorusu
2. "Birtakım harflerden oluşan (öyle görüyoruz) metinler (programların kaynak kodları) nasılcompile ediliyor? ” ​**un götürdüğü klişe olan** ​“Her şey 0 ve 1’lerden ibarettir.” , “Nasıl oluyorda çok karmaşık gelen hesap işlerimizi kolayca yapabiliyoruz? ” ​**soruları**

Bu iki soru silsilesine cevap vermek pek kolay olmayacak.Bunlar farklı varyasyonlarla farklışekillerde sorulabilir.Ancak burada bir kitap ele almadığım, blog yazısı yazdığım için oldukçabasit ve tafsilatsız şekilde açıklamaya gayret edeceğim. O yüzden bu soruları iki gruba ayırarak, iki başlıkta ele alacağım. Bunlardan birincisi “CPU” merkezli olacak ama “ram” ve“sair çevre birimleri” nden de bahislerin yer alacağı bir başlık olacaktır. Diğer başlık da “CPU”merkezli olacak ancak bu sefer kitabın kapağına bakmak yerine açıp sayfalarına bakacağız.Bu analojiyi yazıyı okumaya devam edip bitirdiğinizde anlayacaksınız.Belki de zatenanladınız, bilmiyorum...

#### CPU vs Learner – CPU vs Öğrenen
![cpu vs learner](https://ffc12.github.io/docs/assets/images/cpu.png)


CPU yani merkezi işlem birimi için bir ad aktarması yapacak olsaydık doğrudanbilgisayar olarak ifade edilebilirdi. Yani bir anlamda bilgisayarın beyni olan bu donanımbulunmadığı sürece bilgisayardan söz etmek mümkün değildir. Tanım olarak, bilgisayarın içerisinde yer alabilen veya harici olarak da (microprocessor-microcontroller) gömülü sistemlerde kullanılabilen, görevi kendisine verilen instruction-ları işlemek olan bir elektronik devredir. Bu tanımı biraz daha açmamız gerekiyor.

Öncelikle “instruction” kendi başına bir başlıkta incelenmesi gereken bir konu ihtiva ediyor.Bunu başka ve mustakil bir yazıda ele alacağım. Ama özetle bu instruction-lar bilgisayarların işlemcilerinin elektronik devrelerinin sahip olduğu mantıksal işlemlerikullanarak, “programlamak” dediğimiz eylemi yapabilmemiz için benzersiz numaralarla soyutlanmış ve standartlaştırılmış bir modelin birer kuralı olarak düşünülebilir; bu instructionları daha iyi anlamak ve üzerinde çalışabilmek için bu benzersiz numaralarının bizlere anlamlı gelen kelimelerle ilişkilendirilmesiyle de Assembly dediğimiz dili elde etmiş oluruz.

Bu mantıksal işlemler bir noktada aritmetik işlemleri de yapabilecek şekilde gruplandırıldığıiçin en temelde bir veya iki adet bildiğimiz,anladığımız sayıları (1,2,1002323 vb. gibi)kullanarak önceden belirlenmiş veya devre üzerinde mapped edilmiş (haritalanmış) yollar üzerinde elektrik akışını(elektrik yolu) sağlamaktadır diyebiliriz.Yani belli bir sayı aralığında tüm ihtimalleri düşünülmüş mantıksal ve aritmetik işlemleri yapabilecek şekilde tasarlanmış bu devrenin, kendisi için belirlenmiş benzersiz numaralara göre farklı kombinasyonlarda devre üzerinde birer elektrik akış yolu bulunur.Bu kısım elektrik-elektronik bilgisi olmayan birileri için anlaması güç olabilecek bir kısım olmuş olabilir.

Biraz daha açmaya ve açıklamaya çalışalım.Düşünün ki 1,2,3 veya 4 gibi sayılar gerçekdünyada, matematikte aslında soyutturlar; 1 ile el sıkışamazsınız mesela , somut şekilde bu mümkün değil.Ancak parmaklarınızı ele alalım, sizin zaten elinizde biliyorum.1 sayısını göstermek için sadece işaret parmağınızı havada, parmak boğumlarınızı aynı doğrultuda tutarak, göstermeniz pekala mümkündür.Böylelikle evrensel olarak 1 sayısını somut şekilde göstermiş olabilirsiniz. Bu elektriğe veya elektrik devrelerine aslında işaret parmağında gerçekleşmiş mekanik hakeretlere benzer bir şekilde atom altı etkileşimleri kullanarak ona 1’igöstertmek ve evrensel olarak bizim kabul ettiğimiz (standart model) somut bir işiyaptırmaktır.Dolayısıyla bir elimizdeki soldan ilk üç parmağın parmak boğumlarınının herbirisini kendi üç-boyutlu koordinat sistemi içinde aynı doğrultuda tutarsak (açarsak) ve kalan parmaklarımızın parmak boğumlarını aynı doğrultuda tutmazsak (kapatırsak) neticede 3 sayısını bir elimizi kullanarak göstermiş oluruz.Elektrik için de buradaki gibi mekanik olmasada aslında parmakları açıp kapatarak farklı sayıları göstermesine benzer bir mantıkla çalışacak devre kurabiliriz.Nitekim öyle de olmuş; CPU ve binlerce farklı donanım gündeme gelmiştir. Ve yine belki iki elimizi kullanırsak farklı şekillerle de aynı işaret dilinde olduğu gibibelli kelimeleri parmaklarımızla ifade edebiliriz. Neticede işte bu analojideki parmaklarımızı göstererek bu kelimeleri anlamamız veya anlatmamız Assembly dili soyutlaması olurken,parmaklardaki mekanik hareketlerin farklı şekillerde ifade ettikleri benzersiz durumları da önceden bizim belirlediğimiz standart olmuş oluyor diyebiliriz.Bu standartlara da bilgisayar için ISA (Instruction set architecture) ismi verilmektedir.Buna mimari ya da bilgisayar mimarisi de denilebilir.Bu ISA ile işlemcinin kullanabileceği data tipleri, registerlar, bir memory-i nasıl yöneteceği ve I/O (input-output) iletişiminin nasıl gerçekleşeceği -bu kavramları yazılarımızda açıklayacağız- binlerce farklı senaryo için numaralandırılmış (yukarıda uzunca anlattık, *parmaklarla gösterilmiş*) ve devre bu şekilde tasarlanarak üretilmiştir.En nihayetinde de biz insanların anlamasını kolaylaştırmak, yazılımadı verdiğimiz eylemi yaparken programları kolay ifade edebilmek için, sonra Assembly diliadı altında bu numaralar çeşitli kelimelerle soyutlanmıştır.Bu noktada fazla derine gitmeden son olarak günümüzde iki tane ISA modelinin olduğundan bahsederek bir sonraki başlığageçelim.Bu standart modellerden birisi CISC (Complex instruction set computer) ve diğeri de RISC’dir(Reduced instruction set computer). Bunların farkları bu yazının konusu değil ama özetle CISC daha donanım merkezci, karmaşık instruction-lar içerirken ve RAM dostu bir mimariyken, RISC daha yazılım merkezci,basit instruction-lar içeren ve ağır RAM kullanımına yol açabilen bir mimaridir.

#### Okus Pokus Compilus (Düzenleme yapılacak..)

Compiler-lar günümüzde, belki de, biz farkında olmasak da en önemli konulardanbirisidir.Compiler-lar ,Assembly hariç, programlama dillerini kullanarak yazılım geliştiren bizyazılımcılar için son derece kıymetli programlardır. Düşünün ki şuan hiçbir compiler olmasakimse en sevdiği programlama dilinde bir yazılım geliştiremeyecektir.Compiler tarafındanihtimaldir ki yapılan optimizasyonlarla, hem son kullanıcıyı, hem işlemciyi ve hem de
yazılımcıyı memnun etmenin yolları aranmaktadır. Ve bunu en dengeli şekilde yapmak içinilk gündeme geldiği zamandan beridir yoğun şekilde bu alanda çalışmalar yapılmaktadır.Temelde compiler dediğimiz program yazdığınız kaynak kodlarını (bir grup sözcük vekarakter) işleyerek-belli kurallara uyup,uymadığını kontrol ederek, bunları bir Assembly dilineçevirir. Günümüzde her programlama dili elbette doğrudan platforma Assembly koduüretecek şekilde low-level tasarlanmamıştır. Şuan güneşli dünyada, Java,C# ve JavaScriptgibi pekçok dil sanal makineler üzerinde (bir nevi işlemciyi taklit eden programlar) çalışarakbunu sağlamaktadırlar. Tabi bu dilleri böyle tasarlamış olmalarının birçok sebepleri veavantajları var.Bunu araştırmanızda fayda olacaktır.Ayrıca bu tip dillere literatürde high-level programlama dilleri deniliyor.Buna sebep de bubahsettiğimiz sanal makine yaklaşımıyla çalışmaları gösterilebilir. Diğer taraftan C,C++ veRust gibi diller platforma Assembly kodu üreterek çalışırlar.Bu bakımdan bu programlamadillerine de low-level diller denilmektedir. Burada high-low ilişkisi biraz da söz konusu dilinAssembly diline yakınlığına göre belirlenmektedir.Süreci başa sarmıştık.Ve işlemcinin nasıl çalıştığına cevap vermiştik.Hatta Assembly diliseviyesine kadar açıklamaya çalışmıştık.Önceden belirlenmiş benzersiz numaralarvardı.Bunlar farklı şekillerde elektriğin devreden geçmesiyle ortaya çıkan benzersizdurumlarla ilişkilendirilmiş numaralardı. Bu numara daha sonrasında yine bizlerce bu seferbir kelime ile ilişkilendiriliyordu:●10 ‘a “taşı”●11 ‘e “artır”şeklinde birer kelime ile “10” ve “11” numaralarının ilişkilendirildiklerini varsayalım.Dolayısıylaben günün sonunda bu iki “instruction” için gerekli kelimeyi birleştirerek bir “instruction” –komut verebilirim.Bunu anlamlı hale getirmek için -çünkü bir hesap yapmasını bekliyorum-bildiğim ve anladığım sayıları da kullanabilmeliyim.Dolayısıyla bunu biraz geliştiriyorum vebir sayıdan önce mesela 19 geliyorsa, her zaman ondan (19) sonra gelenin bir sayıolduğunu bilecek şekilde devremi tasarlamış olduğumu varsayıyorum. Yani:şeklinde kelimelerimle devremin üzerinde birer yolu temsil edecek benzersiz numaralarıilişkilendirdim.Dolayısıyla artık mesela elimde 200 sayısı varsa ve eğer ben bunu klavyedenalıp, daha sonra 202’ye kadar arttırmak istiyorsam kabaca şöyle bir şekilde kodlamamgerektiğini düşünebilirim:bunu kelimelerle ifade edersem10 ​'a "taşı"11 ​'e "artır"19 ​'a "sayı öneki"10 19​​200​​11​​11ta​şı 200
Bu pratikte çok doğru olmayabilir.Hatta aklınıza gelen “taşı” neden sayıdan önce nedensonra değil gibi bir sürü soru olabilir. Bunları şimdilik sinenize çekmenizi istiyorum.Çünkü buörnek tamamen anlatabilmem için pseudo-instruction ve opcode-lardan oluşuyor.Yanimesele öğrenmek ve anlamak olarak düşünülebilir bu örnek için.Ancak burada “opcode” diyeyeni bir kavramla tanışıyoruz.Instruction Altı Parçacıklar *OpcodesBaşta anlattığımız, devrenin bir durumunun benzersiz bir numara ile ilişkisinin olmasıylabenzersiz numaranın da yine aynı şekilde bir kelimeye karşılık gelmesi ilişkilerini biraz dahaaçmam bu noktada çok anlamlı olacaktır. Devre durumu-benzersiz numara ilişkisinde birfarklılık yok. Ancak benzersiz numara ve kelime ilişkisini kurarken işlemcinin aynı anda kaçbitlik data-yı işleyebileceğini düşünerek ve bu kapasitesiyle en fazla ne kadarlık bir numaraveya numaralar dizisini alabilir bunu da düşünmemiz gerekiyor. Sözgelimi mesela 8-bitlik birişlemci için düşünecek olursak aynı anda tek bir​​cycle​-da 8-bitten oluşan “instruction” yaninumara veya numaralar dizisi alabilir, işleyebilir.Şuana kadar hep numara veya numaralardiye bahsettiğimiz bu kodların literatürdeki ismi ​binary format yada binary file ​olarakgeçer.Binary format isminden de anlaşılacağı üzere buradaki “data” aslında ikilik tabandaifade edilebilir olduğu gibi, onaltılık ve onluk tabanda da ifade edilebilir.Bu seçim ve gösterimtamamen soyut.Neticede bundan sonra biz de yeterince anladığımız bu kavramları gerçekisimleriyle zikredebiliriz.Ayrıca buradaki cycle, CPU’nun nasıl çalışacağını bildiren/gösteren“instruction”ların her birisinin bilumum kapasitesi yada bu işlemi gerçekleştirme süresi içinkullanılan bir kavramdır.Genel tanım, “instruction cycle” diye zikredilebilecek olan veCPU’nun bilgisayarı boot edip kapatmasına kadarlık süreçte üç aşamadan oluşan biryaklaşımla “instruction”ları işlemesi olarak yapılabilir. Bu işleme sürecinin birim süresi deCPU’nun kapasitesine (8-bit mi,16-bit mi,32-bit mi? ) bağlı olarak her 8-bitlik (16-bit veya32-bit de olabilir) tam kapasite (yani 8-bitlik bir data) bir iş için cycle-larla ifade edilmektedir.Bu bir cycle-da üç aşamadan meydane gelir; ​fetch​, ​decode​ ve ​execute​.Bunu somut bir örneği ele alarak daha iyi anlamaya çalışalım.Mesela 8-bitlik bir işlemciyle 4cycle-da yapabileceğim iş ihtiva eden toplam 32-bitlik bir “instruction” paketi, aynı işi 32-bitlikbir işlemci ile tek 1 cycle-da yapabilirim. Bu da aynı zamanda: “Neden 8-bit,16-bit veya 32-bitolması işlemci cihetiyle önemlidir sorusuna”, işte bu, sebeplerden bir tanesi olarakgösterilebilir; çünkü işlem yapabilme kapasitesi olan birim cycle-da 8-bit ve 32-bitlikişlemciler arasında kapasite olarak da 1/4 oran bulunacaktır.Bu noktada karşımıza şöyle bir önem arz eden durum çıkacaktır: ​Öyleyse işlemcinin dahaperformanslı çalışabilmesi için mümkün mertebe işlerimi en az sayıda cycle-layaptırmalıyım​. Yani yapacağım iş için yazacağım “instruction”ının iyi şekilde ​encodeedilmesini sağlamalıyım.Böylelikle işlemciye en kısa sürede yaptırmak istediğim işiyaptırabilirim. ​Tabieğermümkünse8-bitbirişlemciyerineelbette32-bitbirişlemcitercihetmeliyim.artı​rartı​r
Encode edilmesinden murad burada, öyle bir sistematik hazırlamalıyız ki mesela 3 ayrıcycle-da yapılan bir işi, instruction-ları, biraz daha karmaşıklaştırarak ama tek bir“instruction” şeklinde işlemciye vererek, yani benzersiz numaralandırmaları mümkünolduğunca sıkıştırarak kullanmak istiyorum.Genelde sanıldığının aksine ancak buradakelimeler ile yaptığımız soyutlamayı değiştirmek zorunda değiliz. Nitekim işlemci için anlamlıolacak olan şey bir tane “instruction” olacak.Senin ona “ali” veya “veli” ismini vermiş olmançok da umrunda değil; olamaz.Yani, unutmayın, bizim ne dediğimizin hiçbir önemi işlemcinazarında yok.Yukarıdaki örnek pseudo-instruction-lara geri dönüyorum:buradaki benzersiz numaraları kullanarak,soyutladığım kelimelerle bir program yazmıştım ve aslında bu program şu şekildedönüştürülüyordu.Aslında bu tam olarak yaygın kullanımda bu şekilde ifade edilmez.Genelde hexadecimal yanionaltılık taban kullanılarak “0x” prefix’i ile kullanılır:(Hexadecimal gösterime dair bir bilginiz yoksa, bu konuyu en kısa süredeöğrenmenizde fayda var.)Bu pseudo-instruction-ı oluştururken demiştik ki bir sayıyı işlemek istiyorsak onun önüne “19”sayısını getirmiş olalım; yani ​0x13​ burada ardınca gelenlerin işlenecek data olduğunugösteren bir özel numaraydı. Bunun gibi bir data-nın olduğunun gösterilmesi ile ilgilinumaralar ve data-nın kendisi haricindeki tüm ifadelere “​opcode​” denilmektedir.Yani 0x0Ave 0x0B birer ​opcode​‘tur.Peki data-nın kendisinin hiçbir ismi bulunmuyor mu? Hayır,bulunuyor: “​operand​” şeklinde ifade edilmektedir.Özetle, bir ​instruction​ işlemci ​kapasitesi​ne göre (8-bit mi , 32-bit mi ?) ve o işlemcinin ​ISAstandart​ına göre belirlenmiş (kelimelerle soyutlanmış) ​opcode​-lar ve bunların belirttiğiişlemlerin yapılabilmesi için gereken ​operand​-lardan (data) oluşmaktadır. Bu “instruction”ınoluşturulması işlemine de “​instruction encoding​” denilmektedir.Bu encode işlemi deişlemcinin kapasitesine göre ( bir cycle-da kaç bitlik data işleyebilir ) yapılmaktadır. Bukonuyu müstakil bir yazıda teferruatlı bir şekilde ele alacağım.Muhtemelen başlığı da“​Instruction Anatomisi​” olacaktır.

`   10 'a "taşı"
    11 'e "artır"
    19 'a "sayı öneki" `

taşı 200
artır
artır10 
19 200 11 11
0A  13 C8  0B  0B
SonuçYukarıda oldukça baside indirgeyerek ve birkaç farklı analoji yaparak cevaplamayaçalıştığımız “Bir işlemci nasıl çalışır?” ve “Compiler 0 ve 1-lere dönüştürüyor ama peki bunasıl çalışıyor?” soruları oldukça detaylı cevaplara sahiptir. Filhakika bizim buradakianlattıklarımız çok umumi ve son derece yüzeysel olmakla beraber Assembly ileprogramlamak ve Assembly’nin nasıl çalıştığını anlamak için aslında temel bir bakışkazandırabilmekti. Buradan hareketle aslında çeşitli konulara dair iplerin ucunu ellerinizeverdik. Takip edip daha tafsilatlı bir şekilde konular üzerinde ihtisas yapmak sizlerekalmıştır.Buna en altta paylaşttığım linklerdeki okumaları yaparak başlayabilirsiniz.Toplamda bu mukaddime hariç 6 yazıdan oluşacağını tahmin ettiğim Assembly yazıdizgesini sonuna kadar okumanızı tavsiye ederim:1.x86 Assembly 1. Bölüm : Intel vs AT&T2.x86 Assembly 2. Bölüm : “Hello, world”3.x86 Assembly 3. Bölüm : Addressing Modes4.x86 Assembly 4. Bölüm : Stack ve Avanesi5.x86 Assembly 5. Bölüm : Macro-lar Dost Mudur Düşman Mıdır?6.x86 Assembly 6. Bölüm : C İthalat-İhracat AŞ.

Okuma Listesi
●https://stackoverflow.com/a/6463981/15258319
●https://en.wikipedia.org/wiki/Central_processing_unit#:~:text=The%20actual%20mathematical%20operation%20for,storing%20the%20result%20to%20memory.
●https://en.wikipedia.org/wiki/Instruction_set_architecture
●https://www.microcontrollertips.com/risc-vs-cisc-architectures-one-better/
●https://www.techopedia.com/definition/938/binary-format
●https://en.wikipedia.org/wiki/Instruction_cycle
●https://en.wikipedia.org/wiki/Opcode
●Operating Systems: From 0 to 1'ın 4. bölümü